import scala.collection.mutable.ListBuffer
import scalanativecrossproject.NativePlatform
import sbtcrossproject.{JVMPlatform, CrossProject, CrossClasspathDependency}
import zio.sbt.githubactions.{Job, Step, ActionRef}
import scala.annotation.tailrec
import scala.sys.process._
import zio.json.ast.Json

enablePlugins(ZioSbtEcosystemPlugin, ZioSbtCiPlugin)

def withCurlInstallStep(j: Job) = j.copy(steps = j.steps.flatMap {
  case s: Step.SingleStep if s.name.contains("Install libuv") =>
    List(
      Step.SingleStep(
        name = "Install libcurl",
        run = Some("sudo apt-get update && sudo apt-get install -y libidn2-dev libcurl3-dev"),
      )
    )
  case s => updatedBuildSetupStep(s)
})

def withBuildSetupUpdate(j: Job) = j.copy(steps = j.steps.flatMap(updatedBuildSetupStep))

def updatedBuildSetupStep(step: Step) = step match {
  case s: Step.SingleStep if s.name.contains("Setup Scala") => Nil
  case s: Step.SingleStep if s.name.contains("Setup SBT")   =>
    List(
      Step.SingleStep(
        name = "Setup build tools",
        uses = Some(ActionRef("VirtusLab/scala-cli-setup@main")),
        parameters = Map("apps" -> Json.Str("sbt"), "jvm" -> Json.Str("temurin:21")),
      )
    )
  case s: Step.SingleStep if s.name == "Test" =>
    List(s.copy(run = Some("sbt buildCodegenBin +test")))
  case s: Step.SingleStep if s.name == "Check all code compiles" =>
    List(s.copy(run = Some("sbt buildCodegenBin +Test/compile")))
  case s: Step.SingleStep if s.name == "Lint" =>
    List(s.copy(run = Some("sbt buildCodegenBin lint")))
  case s => List(s)
}

val _scala3 = "3.3.7"

val scala3Next = "3.7.4"

val _zioVersion = "2.1.24"

val sttpClient4Version = "4.0.14"

val jsoniterVersion = "2.38.8"

val codegenVersion = "0.0.13"

inThisBuild(
  List(
    name         := "ZIO Google Cloud clients",
    zioVersion   := _zioVersion,
    organization := "com.anymindgroup",
    licenses     := Seq(License.Apache2),
    homepage     := Some(url("https://anymindgroup.com")),
    developers   := List(
      Developer(id = "rolang", name = "Roman Langolf", email = "rolang@pm.me", url = url("https://github.com/rolang")),
      Developer(
        id = "dutch3883",
        name = "Panuwach Boonyasup",
        email = "dutch3883@hotmail.com",
        url = url("https://github.com/dutch3883"),
      ),
      Developer(
        id = "qhquanghuy",
        name = "Huy Nguyen",
        email = "huy_ngq@flinters.vn",
        url = url("https://github.com/qhquanghuy"),
      ),
    ),
    scala3             := _scala3,
    scalaVersion       := _scala3,
    crossScalaVersions := Seq(_scala3),
    versionScheme      := Some("early-semver"),
    ciEnabledBranches  := Seq("master"),
    ciTestJobs         := ciTestJobs.value.map(withCurlInstallStep),
    ciBuildJobs        := ciBuildJobs.value.map(withBuildSetupUpdate),
    ciLintJobs         := ciLintJobs.value.map(withBuildSetupUpdate),
    ciJvmOptions ++= Seq("-Xms2G", "-Xmx5G", "-Xss4M", "-XX:+UseG1GC"),
    ciDefaultJavaVersion := "21",
    ciTargetJavaVersions := Seq("21"),
    ciReleaseJobs        := ciReleaseJobs.value.map(withBuildSetupUpdate),
    pomIncludeRepository := { _ => false },
    publishMavenStyle    := true,
    publishTo            := {
      val centralSnapshots = "https://central.sonatype.com/repository/maven-snapshots/"
      if (isSnapshot.value) Some("central-snapshots" at centralSnapshots)
      else localStaging.value
    },
    ciReleaseJobs := ciReleaseJobs.value
      .map(withBuildSetupUpdate)
      .map(j =>
        j.copy(
          steps = j.steps.map {
            case Step.SingleStep(name @ "Release", _, _, _, _, _, env) =>
              Step.SingleStep(
                name = name,
                run = Some(
                  """|echo "$PGP_SECRET" | base64 -d -i - > /tmp/signing-key.gpg
                     |echo "$PGP_PASSPHRASE" | gpg --pinentry-mode loopback --passphrase-fd 0 --import /tmp/signing-key.gpg
                     |(echo "$PGP_PASSPHRASE"; echo; echo) | gpg --command-fd 0 --pinentry-mode loopback --change-passphrase $(gpg --list-secret-keys --with-colons 2> /dev/null | grep '^sec:' | cut --delimiter ':' --fields 5 | tail -n 1)
                     |sbt 'buildCodegenBin; publishSigned; sonaRelease'""".stripMargin
                ),
                env = env,
              )
            case s => s
          }
        )
      ),
    // this overrides the default post release jobs generated by zio-sbt-ci which publish the docs to NPM Registry
    // can try to make it work with NPM later
    ciPostReleaseJobs          := Nil,
    ciCheckWebsiteBuildProcess := Nil,
  )
)

lazy val commonSettings = List(
  javacOptions ++= Seq("-source", "21"),
  Compile / scalacOptions ++= Seq("-source:future", "-rewrite"),
  Compile / scalacOptions --= sys.env.get("CI").fold(Seq("-Xfatal-warnings"))(_ => Nil),
  Test / scalafixConfig := Some(new File(".scalafix_test.conf")),
  Test / scalacOptions --= Seq("-Xfatal-warnings"),
  semanticdbEnabled := true,
  semanticdbVersion := scalafixSemanticdb.revision, // use Scalafix compatible version
)

val noPublishSettings = List(
  publish         := {},
  publishLocal    := {},
  publishArtifact := false,
  publish / skip  := true,
)

lazy val gcpClientsCrossProjects: Seq[CrossProject] = for {
  (apiName, apiVersion) <- Seq(
                             "aiplatform"     -> "v1",
                             "iamcredentials" -> "v1",
                             "pubsub"         -> "v1",
                             "storage"        -> "v1",
                             "sheets"         -> "v4",
                             // new clients can be added here
                             // 1. Place the specs into codegen/src/main/resources folder e.g.:
                             // curl 'https://redis.googleapis.com/$discovery/rest?version=v1' > codegen/src/main/resources/redis_v1.json
                             // 2. add to configuration here according to the json file name "redis_v1.json" like:
                             // "redis"          -> "v1",
                           )
  httpSource <- Seq("Sttp4")
  jsonCodec  <- Seq("Jsoniter")
  arrayType  <- Seq("ZioChunk")
  name        = s"zio-gcp-$apiName".toLowerCase()
  id          = s"$name-$apiVersion".toLowerCase()
} yield {
  CrossProject
    .apply(id = id, base = file(id))(JVMPlatform, NativePlatform)
    .settings(commonSettings)
    .dependsOn(zioGcpAuth)
    .settings(
      Compile / scalacOptions --= Seq("-Xfatal-warnings"),
      Compile / sourceGenerators += codegenTask(
        apiName = apiName,
        apiVersion = apiVersion,
        httpSource = httpSource,
        jsonCodec = jsonCodec,
        arrayType = arrayType,
      ),
      libraryDependencies ++= Seq(
        "com.softwaremill.sttp.client4"         %%% "core"                  % sttpClient4Version,
        "com.github.plokhotnyuk.jsoniter-scala" %%% "jsoniter-scala-core"   % jsoniterVersion,
        "com.github.plokhotnyuk.jsoniter-scala" %%% "jsoniter-scala-macros" % jsoniterVersion % "compile-internal",
        "dev.zio"                               %%% "zio"                   % _zioVersion,
      ),
    )
}

lazy val gcpClients: CompositeProject = new CompositeProject {
  override def componentProjects: Seq[Project] = gcpClientsCrossProjects.flatMap(_.componentProjects)
}

lazy val gcpClientsProjects: Seq[ProjectReference] = gcpClients.componentProjects.map(p => LocalProject(p.id))

lazy val cliBinFile: File = {
  val binTarget = new File("codegen/target/bin")

  def normalise(s: String) = s.toLowerCase.replaceAll("[^a-z0-9]+", "")
  val props                = sys.props.toMap
  val os                   = normalise(props.getOrElse("os.name", "")) match {
    case p if p.startsWith("linux")                         => "linux"
    case p if p.startsWith("windows")                       => "windows"
    case p if p.startsWith("osx") || p.startsWith("macosx") => "macosx"
    case _                                                  => "unknown"
  }

  val arch = (
    normalise(props.getOrElse("os.arch", "")),
    props.getOrElse("sun.arch.data.model", "64"),
  ) match {
    case ("amd64" | "x64" | "x8664" | "x86", bits) => s"x86_${bits}"
    case ("aarch64" | "arm64", bits)               => s"aarch$bits"
    case _                                         => "unknown"
  }

  binTarget / "bin" / s"gcp-codegen-$arch-$os"
}

lazy val buildCodegenBin = taskKey[File]("")
buildCodegenBin := {
  val built = (codegen / Compile / nativeLinkReleaseFast).value
  IO.copyFile(built, cliBinFile)
  cliBinFile
}

def codegenTask(
  apiName: String,
  apiVersion: String,
  httpSource: String,
  jsonCodec: String,
  arrayType: String,
) = Def.task {
  val logger        = streams.value.log
  val codegenBin    = cliBinFile
  val outDir        = (Compile / sourceManaged).value
  val targetBasePkg = s"${organization.value}.gcp.$apiName.$apiVersion"
  val outPkgDir     = outDir / targetBasePkg.split('.').mkString(java.io.File.separator)

  if (!codegenBin.exists()) {
    throw new InterruptedException(
      s"Command line binary ${codegenBin.getPath()} was not found. Run 'sbt buildCodegenBin' first."
    )
  } else {
    @tailrec
    def listFilesRec(dir: List[File], res: List[File]): List[File] =
      dir match {
        case x :: xs =>
          val (dirs, files) = IO.listFiles(x).toList.partition(_.isDirectory())
          listFilesRec(dirs ::: xs, files ::: res)
        case Nil => res
      }

    if (outPkgDir.exists() && outPkgDir.listFiles().nonEmpty) {
      logger.info(s"Skipping code generation. $apiName client sources found in ${outPkgDir.getPath()}.")
      listFilesRec(List(outPkgDir), Nil)
    } else {
      import sys.process.*

      logger.info(s"Generating Google client sources")

      val errs = ListBuffer.empty[String]
      List(
        s"${codegenBin.getPath()}",
        s"-out-dir=$outDir",
        s"-out-pkg=$targetBasePkg",
        s"-specs=codegen/src/main/resources/${apiName}_${apiVersion}.json",
        s"-http-source=$httpSource",
        s"-json-codec=$jsonCodec",
        s"-array-type=$arrayType",
        s"-jsoniter-json-type=_root_.com.anymindgroup.jsoniter.Json",
      ).mkString(" ") ! ProcessLogger(i => logger.debug(i), e => errs += e) match {
        case 0 => ()
        case c => throw new InterruptedException(s"Failure on code generation:\n${errs.mkString("\n")}")
      }

      val files = listFilesRec(List(outPkgDir), Nil)
      logger.success(s"Generated ${files.length} files in ${outPkgDir.getPath()}")
      files
    }
  }
}

lazy val root =
  (project in file("."))
    .aggregate(
      zioGcpAuth.jvm,
      zioGcpAuth.native,
      zioGcpStorage.jvm,
      zioGcpStorage.native,
      zioGcpSheets.jvm,
      zioGcpSheets.native,
      tests.jvm,
      tests.native,
    )
    .aggregate(gcpClientsProjects *)
    .settings(commonSettings)
    .settings(noPublishSettings)

lazy val codegen = (project in file("codegen"))
  .settings(
    scalaVersion := "3.7.4",
    libraryDependencies ++= Seq(
      "dev.rolang" %%% "gcp-codegen-cli" % codegenVersion
    ),
  )
  .enablePlugins(ScalaNativePlugin)

lazy val zioGcpAuth = crossProject(JVMPlatform, NativePlatform)
  .in(file("zio-gcp-auth"))
  .settings(moduleName := "zio-gcp-auth")
  .settings(commonSettings)
  .settings(
    scalacOptions --= List("-Wunused:nowarn"),
    libraryDependencies ++= Seq(
      "dev.zio"                               %%% "zio"                   % zioVersion.value,
      "com.softwaremill.sttp.client4"         %%% "core"                  % sttpClient4Version,
      "com.github.plokhotnyuk.jsoniter-scala" %%% "jsoniter-scala-core"   % jsoniterVersion,
      "com.github.plokhotnyuk.jsoniter-scala" %%% "jsoniter-scala-macros" % jsoniterVersion  % "compile-internal",
      "dev.zio"                               %%% "zio-test"              % zioVersion.value % Test,
      "dev.zio"                               %%% "zio-test-sbt"          % zioVersion.value % Test,
    ),
  )
  .jvmSettings(
    libraryDependencies ++= Seq(
      "com.softwaremill.sttp.client4" %%% "zio" % sttpClient4Version
    )
  )
  .nativeSettings(
    Compile / scalacOptions --= Seq("-Xfatal-warnings"),
    libraryDependencies ++= Seq(
      "io.github.cquiroz" %%% "scala-java-time" % "2.6.0"
    ),
  )

lazy val zioGcpStorage = crossProject(JVMPlatform, NativePlatform)
  .in(file("zio-gcp-storage"))
  .settings(moduleName := "zio-gcp-storage")
  .settings(commonSettings)
  .dependsOn(zioGcpAuth)
  .dependsOn(
    gcpClientsCrossProjects
      .filter(_.projects.exists { case (_, p) =>
        Set("zio-gcp-storage-v1", "zio-gcp-iamcredentials-v1").exists(p.id.startsWith(_))
      })
      .map(p => new CrossClasspathDependency(p, p.configuration)) *
  )

lazy val zioGcpSheets = crossProject(JVMPlatform, NativePlatform)
  .in(file("zio-gcp-sheets"))
  .settings(moduleName := "zio-gcp-sheets")
  .settings(commonSettings)
  .dependsOn(zioGcpAuth)
  .dependsOn(
    gcpClientsCrossProjects
      .filter(_.projects.exists { case (_, p) =>
        Set("zio-gcp-sheets-v4").exists(p.id.startsWith(_))
      })
      .map(p => new CrossClasspathDependency(p, p.configuration)) *
  )
  .settings(
    libraryDependencies ++= Seq(
      "com.github.plokhotnyuk.jsoniter-scala" %%% "jsoniter-scala-macros" % jsoniterVersion % "compile-internal"
    )
  )

lazy val examples = crossProject(JVMPlatform, NativePlatform)
  .in(file("examples"))
  .dependsOn(zioGcpAuth, zioGcpStorage, zioGcpSheets)
  .dependsOn(gcpClientsCrossProjects.map(p => new CrossClasspathDependency(p, p.configuration)) *)
  .settings(noPublishSettings)
  .settings(
    scalaVersion := scala3Next,
    Compile / scalacOptions ++= Seq("-source:future"),
    crossScalaVersions := Seq(scala3Next),
    fork               := true,
    libraryDependencies ++= Seq(
      "com.github.plokhotnyuk.jsoniter-scala" %%% "jsoniter-scala-macros" % jsoniterVersion % "compile-internal"
    ),
  )

lazy val tests = crossProject(JVMPlatform, NativePlatform)
  .in(file("tests"))
  .dependsOn(zioGcpAuth, zioGcpStorage, zioGcpSheets)
  .dependsOn(gcpClientsCrossProjects.map(p => new CrossClasspathDependency(p, p.configuration)) *)
  .settings(commonSettings)
  .settings(noPublishSettings)
  .settings(
    scalaVersion := scala3Next,
    libraryDependencies ++= Seq(
      "com.github.plokhotnyuk.jsoniter-scala" %%% "jsoniter-scala-macros" % jsoniterVersion  % Test,
      "dev.zio"                               %%% "zio-test"              % zioVersion.value % Test,
      "dev.zio"                               %%% "zio-test-sbt"          % zioVersion.value % Test,
    ),
  )

lazy val docs = project
  .in(file("zio-gcp-docs"))
  .settings(
    moduleName := "zio-gcp-docs",
    scalacOptions -= "-Yno-imports",
    scalacOptions -= "-Xfatal-warnings",
    projectName                                := "Google Cloud clients for ZIO",
    mainModuleName                             := (zioGcpAuth.jvm / moduleName).value,
    projectStage                               := ProjectStage.Development,
    ScalaUnidoc / unidoc / unidocProjectFilter := inProjects(zioGcpAuth.jvm),
    readmeDocumentation                        := "",
    readmeContribution                         := "",
    readmeSupport                              := "",
    readmeLicense                              := "",
    readmeAcknowledgement                      := "",
    readmeCodeOfConduct                        := "",
    readmeCredits                              := "",
    readmeBanner                               := "",
    readmeMaintainers                          := "",
    mdocVariables ++= {
      Map(
        "VERSION" -> {
          // to fix the default impl which returns the oldest tag
          "git tag -l --sort=-v:refname".!!.split("\n").collectFirst {
            case v if v.startsWith("v") => v.tail
          }.getOrElse(version.value)
        },
        "ZIO_GCP_AIPLATFORM_EXAMPLE" -> IO.read(
          file("./examples/shared/src/main/scala/vertex_ai_generate_content.scala")
        ),
        "ZIO_GCP_STORAGE_EXAMPLE" -> IO.read(
          file("./examples/shared/src/main/scala/storage_example.scala")
        ),
        "ZIO_GCP_AUTH_EXAMPLE" -> IO.read(
          file("./examples/shared/src/main/scala/token_provider_examples.scala")
        ),
      )
    },
  )
  .enablePlugins(WebsitePlugin)
